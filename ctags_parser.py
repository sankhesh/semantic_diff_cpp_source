# ctags generated by the command:
# ctags -R --sort=yes --c++-kinds=cf --fields=aksz
# --language-force=C++ --exclude=*.in --exclude=*.java --exclude=*.py -f
# vtk-cf ~/Projects/vtk/src
import re

tagMatcherType1 = re.compile('^(.+)\t(\S+)\t/\^(.*)\$/;"\t(\S+)\n')
tagMatcherType2 = re.compile('^(.+)\t(\S+)\t/\^(.*)\$/;"\t(\S+)\t(\S+)\n')

class Tag:
    name = None
    access = None
    kind = None
    klazz = None
    fyle = None
    decl = None

    def __repr__(self):
        return "<Tag %s in file %s>" % (self.name, self.fyle)

    def parse(self, line):
        """
        Parse a CTags line and set myself from it.
        """
        # example of CTags lines:
        # Type1: ARangeFunctor /home/sankhesh/Projects/vtk/src/Common/Core/Testing/Cxx/TestSMP.cxx /^class ARangeFunctor$/;" kind:c
        # Type2: AbortFlagOff  /home/sankhesh/Projects/vtk/src/Common/Core/vtkCommand.h  /^  void AbortFlagOff()$/;" kind:f  access:public
        tag = tagMatcherType2.search(line)
        # If this is a type 2 tag
        if tag:
            t = tagMatcherType2.search(line)
            self.access = t.expand('\\5').strip().split(':')[1]
        # else if it is type 1 tag
        else:
            tag = tagMatcherType1.search(line)
        if not tag:
            raise KeyError, "line %s is not an expected ctags line" %line
        self.name = t.expand('\\1').strip()
        self.fyle = t.expand('\\2').strip()
        self.decl = t.expand('\\3').strip()
        self.kind = t.expand('\\4').strip().strip().split(':')[1]

class CTags():

    def __init__(self):
        self._tagFile = "" # path to tag file

    def set_tag_file(self, path):
        """
        Parse tags from the given file.
        """
        handle = open(path, "r")
        self._parse(handle.readlines())

    def addString(self, string)
